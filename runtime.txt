python-3.7.4
ACTOPNS /

import axios from "axios";
import { axiosWithAuth } from "../axiosWithAuth";

export const MAKE_STREET_GRID = "MAKE_STREET_GRID";
export const MAKE_FOREST_GRID = "MAKE_FOREST_GRID";
export const MAKE_HOUSE_GRID = "MAKE_HOUSE_GRID";
export const MAKE_GRAVEYARD_GRID = "MAKE_GRAVEYARD_GRID";

export const MOVE_PLAYER = "MOVE_PLAYER";
export const ROOM_INFO = "ROOM_INFO";

export const genericAction = (type, payload, roomTitle, players) => ({
  type,
  payload,
  roomTitle,
  players
});

const url = "http://127.0.0.1:8000/api/adv";

export const sendMessage = payload => dispatch => {
  axios.post(`${url}/say`, payload);
};

export const makeForestGrid = () => dispatch => {
  let currentPosition;
  axiosWithAuth().get(`${url}/init/`)
  .then(res => {
    dispatch(genericAction(ROOM_INFO, res.data))
      debugger
      currentPosition = res.data.title;
      const players = res.data.player;
      return axios.get(`${url}/rooms/`).then(res => {
        if (Number(currentPosition) < 99) {
          dispatch(
            genericAction(MAKE_FOREST_GRID, res.data.rooms, currentPosition, players)
          );
        } else {

          dispatch(
            genericAction(MAKE_STREET_GRID, res.data.rooms, currentPosition, players)
          );
        }
      });
    });
};

export const makeStreetGrid = streetGrid => dispatch => {
  let currentPosition;
  axiosWithAuth()
    .get(`${url}/init/`)
    .then(res => {
      currentPosition = res.data.title;
      const players = res.data.player;
      return axios.get(`${url}/rooms/`).then(res => {

        dispatch(
          genericAction(MAKE_STREET_GRID, res.data.rooms, currentPosition, players)
        );
      });
    });
};

export const makeHouseGrid = houseGrid => {
  return genericAction(MAKE_FOREST_GRID, houseGrid);
};

export const makeGraveyardGrid = graveyardGrid => {
  return genericAction(MAKE_GRAVEYARD_GRID, graveyardGrid);
};

export const moveThePlayer = direction => dispatch => {
  const reqBody = { direction: direction };


  let currentPosition;
  axiosWithAuth()
    .post(`${url}/move/`, reqBody)
    .then(res => {
      currentPosition = res.data.title;
      if (res.data.title === "100") {
        axiosWithAuth()
        .get(`${url}/init/`)
        .then(res => {
          const players = res.data.player;            
          return axios.get(`${url}/rooms/`).then(res => {
            dispatch(
              genericAction(MAKE_STREET_GRID, res.data.rooms, currentPosition, players)
            );
          });
        });
    } else if (res.data.title === "0") {
      axiosWithAuth()
        .get(`${url}/init/`)
        .then(res => {
          const players = res.data.player;
          return axios.get(`${url}/rooms/`).then(res => {
            dispatch(
              genericAction(MAKE_FOREST_GRID, res.data.rooms, currentPosition, players)
            );
          });
        });
    } else {
      dispatch(genericAction(MOVE_PLAYER, currentPosition));
    }
  });
};



////////////////////////////////////////////////

REDUCER 



import * as type from "../actions/gridActions";
import createForest from "../../components/Maps/Forest/ForestFunctions";
import createStreet from "../../components/Maps/Street/StreetFunctions";

const initialState = {
  grid: null,
  playerPosition: null,
  loading: null,
  error: null,
  currentRoom: null
};

const rows = 10;
const cols = 10;

const grid = (state = initialState, action) => {
  switch (action.type) {
    case type.ROOM_INFO:
      return {
        ...state,
        currentRoom: action.payload
      };
      
      case type.MAKE_FOREST_GRID:
        let rooms = action.payload;
        
       // we have a big array with objects // split only the forest world out of it:
      let result = [];

      let i,
        j,
        tempoArray,
        chunk = 100;

      for (i = 0, j = rooms.length; i < j; i += chunk) {
        tempoArray = rooms.slice(i, i + chunk);
        result.push(tempoArray);
      }

      rooms = result[0];


        let grid = [];
      let tempArray = [];
      let keepTrackOfIndex = 9;

      for (let i = 0; i < rooms.length; i++) {
        if (keepTrackOfIndex === i) {
          keepTrackOfIndex += 10;
          tempArray.push(rooms[i]);
          grid.push(tempArray);
          tempArray = [];
        } else {
          tempArray.push(rooms[i]);
        }
      }
const yeadddh = grid
debugger
      const forest = createForest([]);
      let keepTrackOfCurrentForestPosition;
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          if (grid[i][j].title === action.roomTitle) {
            console.log("fotze")
            grid[i][j].start = true;
            keepTrackOfCurrentForestPosition = grid[i][j];
          } else {
            grid[i][j].start = false;
          }
          grid[i][j].i = forest[i][j].i;
          grid[i][j].j = forest[i][j].j;
          grid[i][j].neighbors = forest[i][j].neighbors;
          grid[i][j].treeOne = forest[i][j].treeOne;
          grid[i][j].treeTwo = forest[i][j].treeTwo;
          grid[i][j].treeThree = forest[i][j].treeThree;
          grid[i][j].grave = forest[i][j].grave;
          grid[i][j].goldOne = forest[i][j].goldOne;
          grid[i][j].toStreet = forest[i][j].toStreet;
        }
      }
      const yeah = action.roomTitle
      debugger

      return {
        ...state,
        grid: grid,
        playerPosition: keepTrackOfCurrentForestPosition,
        players: action.players
      };

    case type.MAKE_STREET_GRID:
        let allRooms = action.payload;

        // we have a big array with objects // split only the forest world out of it:
        let theResult = [];
  
        let streetI,
          streetJ,
          tempoStreetArray,
          streetChunk = 100;
  
        for (
          streetI = 0, streetJ = allRooms.length;
          streetI < streetJ;
          streetI += streetChunk
        ) {
          tempoStreetArray = allRooms.slice(streetI, streetI + streetChunk);
          theResult.push(tempoStreetArray);
        }
  
        allRooms = theResult[1];
        let streetGrid = [];
        let tempStreetArray = [];
        let keepTrackOfStreetIndex = 9;
  
        for (let i = 0; i < allRooms.length; i++) {
          if (keepTrackOfStreetIndex === i) {
            keepTrackOfStreetIndex += 10;
            tempStreetArray.push(allRooms[i]);
            streetGrid.push(tempStreetArray);
            tempStreetArray = [];
          } else {
            tempStreetArray.push(allRooms[i]);
          }
        }
  
        const street = createStreet([]);
  
        let keepTrackOfCurrentStreetPosition;
        for (let i = 0; i < rows; i++) {
          for (let j = 0; j < cols; j++) {
            if (streetGrid[i][j].title === action.roomTitle) {
              streetGrid[i][j].start = true;
              keepTrackOfCurrentStreetPosition = streetGrid[i][j];
            } else {
              streetGrid[i][j].start = false;
            }
            streetGrid[i][j].i = street[i][j].i;
            streetGrid[i][j].j = street[i][j].j;
            streetGrid[i][j].neighbors = street[i][j].neighbors;
            streetGrid[i][j].skeleton = street[i][j].skeleton;
            streetGrid[i][j].goldStatue = street[i][j].goldStatue;
            streetGrid[i][j].toForest = street[i][j].toForest;
            streetGrid[i][j].darkTree = street[i][j].darkTree;
            streetGrid[i][j].goldOne = street[i][j].goldOne;
            streetGrid[i][j].grave = street[i][j].grave;
            

          }
        }
      return {
        ...state,
        grid: streetGrid,
        playerPosition: keepTrackOfCurrentStreetPosition,
        players: action.players
      };

    case type.MAKE_HOUSE_GRID:
      return {
        ...state,
        grid: action.payload
      };

    case type.MAKE_GRAVEYARD_GRID:
      return {
        ...state,
        grid: action.payload
      };

    case type.MOVE_PLAYER:
      let currentGrid = [...state.grid];

      let keepTrackOfCurrentPosition;
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          if (currentGrid[i][j].title === action.payload) {
            currentGrid[i][j].start = true;
            keepTrackOfCurrentPosition = currentGrid[i][j];
          } else {
            currentGrid[i][j].start = false;
          }
        }
      }

      return {
        ...state,
        grid: currentGrid,
       playerPosition: keepTrackOfCurrentPosition,
        players: action.players
      };

    default:
      return state;
  }
};

export default grid;
   //////////////////////////////////////////////////////////////////


HOUSEFUNC



const rows = 10;
const cols = 10;

const createStreet = (grid) => {
  for (let i = 0; i < rows; i++) {
    const currentRow = [];
    for (let j = 0; j < cols; j++) {
      currentRow.push(createNode(i, j));
    }
    grid.push(currentRow);
  }

  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      addNeighbors(grid, i, j);
    }
  }

  return grid;
};

const createNode = (i, j) => {
  return {
    i: i,
    j: j,
    start: i === 0 && j === 0, // create start point
    neighbors: [],
    goldStatue:
    (i === 3 && j === 9) || (i === 1 && j === 2) || (i === 9 && j === 0),
    skeleton: i === 5 && j === 7,
    darkTree:
      (i === 0 && j === 1) ||
      (i === 1 && j === 1) ||
      (i === 2 && j === 1) ||
      (i === 2 && j === 2) ||
      (i === 2 && j === 3) ||
      (i === 4 && j === 1) ||
      (i === 5 && j === 1) ||
      (i === 6 && j === 1) ||
      (i === 7 && j === 1) ||
      (i === 9 && j === 1) ||
      (i === 9 && j === 2) ||
      (i === 9 && j === 3) ||
      (i === 9 && j === 4) ||
      (i === 9 && j === 5) ||
      (i === 4 && j === 2) ||
      (i === 2 && j === 4) ||
      (i === 2 && j === 6) ||
      (i === 2 && j === 7) ||
      (i === 2 && j === 8) ||
      (i === 2 && j === 9) ||
      (i === 4 && j === 3) ||
      (i === 4 && j === 4) ||
      (i === 4 && j === 6) ||
      (i === 4 && j === 7) ||
      (i === 4 && j === 8) ||
      (i === 4 && j === 9) ||
      (i === 1 && j === 6) ||
      (i === 1 && j === 4) ||
      (i === 5 && j === 4) ||
      (i === 6 && j === 4) ||
      (i === 5 && j === 6) ||
      (i === 6 && j === 6) 
      ,
     grave: (i === 0 && j === 9),
     goldOne: (i === 1 && j === 2),
    toForest: i === 9 && j === 8
  };
};

const addNeighbors = (grid, i, j) => {
  if (i < rows - 1) {
    grid[i][j].neighbors.push(grid[i + 1][j]);
  }
  if (i > 0) {
    grid[i][j].neighbors.push(grid[i - 1][j]);
  }
  if (j < cols - 1) {
    grid[i][j].neighbors.push(grid[i][j + 1]);
  }
  if (j > 0) {
    grid[i][j].neighbors.push(grid[i][j - 1]);
  }
};

export default createStreet;




///////////////////////////////////////////



MAINFGAME


import React from "react";
import styled from "styled-components";
import img from "./images/atmosphere-blue-clouds-2531709.jpg";
import { connect } from "react-redux";
import Node from "../Node/Node";
import {
  makeStreetGrid,
  makeForestGrid,
  makeHouseGrid,
  makeGraveyardGrid,
  moveThePlayer,
  sendMessage
} from "../../store/actions/gridActions";
import characterOne from "../Node/images/character_one.png";
import characterTwo from "../Node/images/character_two.png";
import characterThree from "../Node/images/character_three.png";
import characterFour from "../Node/images/character_four.png";
import characterFive from "../Node/images/character_five.png";
import Pusher from 'pusher-js';

// eslint-disable-next-line

class MainGame extends React.Component {
  constructor(props) {
    super(props)

    this.state = {
      text: '',
      chats: [],
      currentRoom: null
    }
  }

  componentDidMount = () => {
    this.createForest();

    window.addEventListener("keydown", e => {
      this.handleKeyDown(e);
    });
  };

  componentDidUpdate = (prevProps) => {
    if (prevProps.currentRoom !== this.props.currentRoom) {
      this.setState({ currentRoom: this.props.currentRoom })
      const pusher = new Pusher('f2df1cd773bc785afe1e', {
        cluster: 'eu',
        forceTLS: true,
        encrypted: true
      });
      console.log('mudroom-'+this.props.currentRoom.title)
      const channel = pusher.subscribe('mudroom-'+this.props.currentRoom.title);
      channel.bind('message', data => {
        this.setState({ chats: [...this.state.chats, data] })
      });
    }
  }

  handleTextChange = (e) => {
    if (e.keyCode === 13) {
      e.preventDefault();
      const payload = {
        room: this.props.currentRoom.title,
        username: this.props.currentRoom.name,
        message: this.state.text
      };
      this.setState({ text: '' })
      this.props.sendMessage(payload)
    } else {
      this.setState({ text: e.target.value });
    }
  }

  handleKeyDown = e => {
    switch (e.keyCode) {
      case 40:
        // down
        if (this.props.playerPosition.i + 1 !== rows) {
          const positionDown = this.props.grid[this.props.playerPosition.i + 1][
            this.props.playerPosition.j
          ];
          if (
            this.props.playerPosition.s_to !== 0 &&
            !positionDown.treeOne &&
            !positionDown.treeTwo &&
            !positionDown.treeThree &&
            !positionDown.skeleton &&
            !positionDown.grave &&
            !positionDown.goldOne &&
            !positionDown.goldStatue &&
            !positionDown.darkTree
          ) {
            this.props.moveThePlayer("s");
          }
          return;
        }
        return;
      case 37:
        // left
        if (this.props.playerPosition.j !== 0) {
          const positionLeft = this.props.grid[this.props.playerPosition.i][
            this.props.playerPosition.j - 1
          ];
          if (
            this.props.playerPosition.w_to !== 0 && // .neighbors.includes(positionLeft) was old code
            !positionLeft.treeOne &&
            !positionLeft.treeTwo &&
            !positionLeft.treeThree &&
            !positionLeft.skeleton &&
            !positionLeft.grave &&
            !positionLeft.goldOne &&
            !positionLeft.goldStatue &&
            !positionLeft.darkTree
          ) {
            this.props.moveThePlayer("w");
          }
          return;
        }
        return;
      case 39:
        // right
        if (this.props.playerPosition.j + 1 !== cols) {
          const positionRight = this.props.grid[this.props.playerPosition.i][
            this.props.playerPosition.j + 1
          ];
          if (
            this.props.playerPosition.e_to !== 0 &&
            !positionRight.treeOne &&
            !positionRight.treeTwo &&
            !positionRight.treeThree &&
            !positionRight.skeleton &&
            !positionRight.grave &&
            !positionRight.goldOne &&
            !positionRight.goldStatue &&
            !positionRight.darkTree
          ) {
            this.props.moveThePlayer("e");
          }
          return;
        }
        return;
      case 38:
        // up
        if (this.props.playerPosition.i !== 0) {
          const positionUp = this.props.grid[this.props.playerPosition.i - 1][
            this.props.playerPosition.j
          ];
          if (
            this.props.playerPosition.n_to !== 0 &&
            !positionUp.treeOne &&
            !positionUp.treeTwo &&
            !positionUp.treeThree &&
            !positionUp.skeleton &&
            !positionUp.grave &&
            !positionUp.goldOne &&
            !positionUp.goldStatue &&
            !positionUp.darkTree
          ) {
            this.props.moveThePlayer("n");
          }
          return;
        }
        return;
      default:
        return;
    }
  };

  createForest = () => {
    this.props.makeForestGrid();
  };

  createStreet = () => {
    this.props.makeStreetGrid();
  };

  createHouse = () => {
    this.props.makeHouseGrid();
  };

  createGraveyard = () => {
    this.props.makeGraveyardGrid();
  };

  movePlayer = (grid, i, j) => {
    grid[this.props.playerPosition.i][
      this.props.playerPosition.j
    ].start = false;
    grid[i][j].start = true;
    return grid;
  };

  render() {
    return (
      <StyledMainGame>
        <table className="grid">
          <tbody>
            {this.props.grid
              ? this.props.grid.map((item, i) => {
                  let entry = item.map((element, j) => {
                    return (
                      <Node
                        key={j}
                        i={element.i}
                        j={element.j}
                        start={element.start}
                        // FOREST
                        treeOne={element.treeOne}
                        treeTwo={element.treeTwo}
                        treeThree={element.treeThree}
                        goldOne={element.goldOne}
                        grave={element.grave}
                        toStreet={element.toStreet}
                        toHouse={element.toHouse}
                        // STREET
                        goldStatue={element.goldStatue}
                        skeleton={element.skeleton}
                        toForest={element.toForest}
                        // HOUSE
                        carpet={element.carpet}
                        smallCabinet={element.smallCabinet}
                        mediumCabinet={element.mediumCabinet}
                        bigCabinet={element.bigCabinet}
                        chair={element.chair}
                        toGraveyard={element.toGraveyard}
                        // GRAVEYARD
                        fence={element.fence}
                        darkTree={element.darkTree}
                        exitStreet={element.exitStreet}
                        // Character
                        character={
                          this.props.character === "characterOne"
                            ? characterOne
                            : this.props.character === "characterTwo"
                            ? characterTwo
                            : this.props.character === "characterThree"
                            ? characterThree
                            : this.props.character === "characterFour"
                            ? characterFour
                            : characterFive
                        }
                      />
                    );
                  });
                  return <tr key={i}>{entry}</tr>;
                })
              : null}
          </tbody>
        </table>
        <div className="game-info">
        <div className="room-info">
        <p>Room {this.props.currentRoom ? this.props.currentRoom.title: ''}</p>
        <h5><u>Roommates</u></h5>
        <ul>
        {this.props.currentRoom ? this.props.currentRoom.players.map((player, index) => {
                  return <li key={index}>{player}</li>
                }) : ''}
                </ul>
                </div>
                <div className="chat-space">
                <div className="message-view">
                {this.state.chats ? this.state.chats.map((chat, index) => {
                    return <div key={index}><span>{chat.username}:</span> <span>{chat.message}</span></div>
                  }): ''}
                </div>
                <div className="input-field">
                <form>
                <input value={this.state.text} onChange={this.handleTextChange} onKeyDown={this.handleTextChange}/>
                </form>
                </div>
              </div>
        </div>
      </StyledMainGame>
    );
  }
}

const StyledMainGame = styled.div`
  background-image: url(${img});
  background-repeat: no-repeat;
  min-height: 100vh;
  padding: 40px;
  display: flex;
  justify-content: space-around;

  .grid {
    border: 5px solid #01134c;
    margin: 20px;
    width: 70%;
    box-shadow: 0px 1.87781px 6.25935px rgba(0, 0, 0, 2.06);
    
  }

  .game-info {
    width: 20%;
    display: flex;
    flex-direction: column;

    .room-info {
      padding: 10px;
      border: 2px solid #01134c;
      width: 100%;
      min-height: 250px;
      height: auto;
      margin-bottom: 30px;
      box-shadow: 0px 1.87781px 6.25935px rgba(0, 0, 0, 2.06);
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 10px;
      .message-view {
        border: 1px solid white;
        background: #fff;
        flex: 1;
        padding: 10px;
        span {
          color: black;
          font-size: 12px;
        }
      }
      .input-field {
        margin-top: 20px;
        input {
          padding: 5px;
        }
        button {
          padding: 5px;
        }
      }
      
      h5 {
        margin-top: 30px;
        color: #fff;
        font-size: 20px;
      }

      li {
        margin-top: 10px;
        color: #fff;
        font-size: 13px;
      }
    }

    .chat-space {
      border: 2px solid #01134c;
      width: 100%;
      min-height: 250px;
      height: auto;
      box-shadow: 0px 1.87781px 6.25935px rgba(0, 0, 0, 2.06);
    }
  }

  .node {
    width: 4rem;
    height: 4rem;
  }

  .node-child {
    display: flex;
    justify-content: center;
    align-items: center;
    background-position: 0 0;
  }
`;

const mapStateToProps = state => {
  return {
    grid: state.grid.grid,
    playerPosition: state.grid.playerPosition,
    character: state.character.character,
    currentRoom: state.grid.currentRoom
  };
};

export default connect(
  mapStateToProps,
  {
    makeForestGrid,
    makeStreetGrid,
    makeHouseGrid,
    makeGraveyardGrid,
    moveThePlayer,
    sendMessage
  }
)(MainGame);

const rows = 10;
const cols = 10;





/////////////////////////


FORESTFUNC
